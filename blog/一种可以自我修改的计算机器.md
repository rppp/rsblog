### 一种可以自我修改的计算机器

有这样一堆可以存储数字的方格：

|0|0|0|0|0|0|0|0|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|0|0|0|0|0|0|0|0|
|0|0|0|0|0|0|0|0|
|...|...|...||||||

如果我们可以对其中任意2个方格进行“或"运算并写入任意1个方格，或者对任意1个方格进行"非"运算并写入任意1个方格，那么由无限个方格和操作组成的机器是图灵完备的吗？答案是肯定的，下面我将给出这种机器的一个实例：

该机器具有如下特点：

- 该机器的所有状态几乎都由自身描述，并且它可以直接改变自己的内部状态（即自我修改，与冯·诺依曼架构类似但又不相同），不像图灵机一样内部状态和纸带是分离的。
- 它的状态转移是清晰可见的，而图灵机由一个内部状态（格局）转移到另一个状态像幽灵一样。
- 它没有未定义行为，也没有停机状态。
- 它有清晰可见的时序实现，而《编码：隐匿在计算机软硬件背后的语言》一书中构造的物理机器时序并不是显而易见的。
- 它的条件跳转和其他所有操作均由“或”和“非”两种基本操作实现（其实只用与非门也行），即由软件实现，而论文《URISC: The Ultimate Reduced Instruction Set Computer》中的条件跳转指令由硬件实现。
- 它使用表格表示，不需要画逻辑电路图，也不需要使用硬件描述语言（HDL）。
- 它既可以很容易地进行书面表示（即人类可读），又可以很容易地构造实际的物理机器。

该机器实例的构成：

1. 有限个方格，每个方格可以存储16位二进制数，即可以表达十进制数0到65535，为了增加可读性本文所有数字都用十进制表示。
2. 每行放8个方格，每个方格都有一个编号，编号从0开始，从左往右递增，从上往下换行，即行主序。
3. 一堆方格可以组成模块，每个模块只能寻址到自身，模块与模块之间可以硬连线。增加模块的目的是增加可读性，如果所有数字都写在一个模块里很可能不是人类可读的。
4. 每个模块都有一个自身的振荡器（即时序），但所有振荡器都是同源的。也就是说，所有模块都是并行的。
5. 每个模块的行为比较简单，它由一个振荡器驱动，反复执行动作。首先，读取第0号方格中的数字，设为a，再读取编号为a的方格中的数字，设为b，根据b的值决定接下来的动作：

- 若b为1，读取后面的3个方格，设为c、d、e，再分别读取编号为c、d的方格，进行“或”运算并写入编号为e的方格。然后再读取后面的3个方格，设为f、g、h，再分别读取编号为f、g的方格，进行“或”运算并写入编号为h的方格。（该步骤执行了两次16位“或”运算）
- 若b为2，读取后面的2个方格，设为o、p，再读取编号为o的方格，进行“非”运算并写入编号为p的方格。然后再读取后面的3个方格，设为q、r、s，再分别读取编号为q、r的方格，进行“或”运算并写入编号为s的方格。（该步骤执行了一次16位“非”运算和一次16位“或”运算）
- 若b为3，读取后面的3个方格，设为c、d、e，再分别读取编号位为c、d的方格位（按位寻址，只读1位），进行“或”运算并写入编号位为e的方格位中。然后再读取后面的3个方格，设为f、g、h，再分别读取编号为f、g的方格，进行“或”运算并写入编号为h的方格。（该步骤执行了一次1位的“或”运算和一次16位的“或”运算）
- 若b为其他值，执行和b为1时同样的动作。

下面通过一个例子来说明：

|8|0|0|0|0|0|0|0|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|2|3|7|1|31|0|32|
|2|7|7|1|38|0|8|0|

该模块的执行流程是：

- 先读取0号方格，即第一行第一列，读到了8，再读取8号方格，即第二行第一列，读到了2，发现这是第二种指令，接下来的两个数字是5和2，所以对第5号方格执行非运算并写入第2号方格。再后面是1、14、0，所以对1号方格和14号方格执行或运算并写入0号方格。可以看到14号方格的值是16，刚好是第三行第一列的编号，而1号方格的值是0，0或16等于16，这就是将16写入了0号方格，这是实现绝对跳转的关键。（这里的“CPU”执行完一条“指令”并不会自动转到下一条“指令”，因此需要我们手动实现）
- 接下来进入下一个振荡器周期，读取0号方格，读到了16，再读取16号方格，读到了2，发现还是第二种指令，执行流程和上面一样。最后24被写入了0号方格。
- 接下来进入下一个振荡器周期，读取0号方格，读到了24，再读取24号方格，读到了1，发现是第一种指令，将2号方格和3号方格进行或运算并写入7号方格，再将1号方格和31号方格进行或运算并写入0号方格，31号方格的值是32，即将32写入了0号方格。
- 接下来进入下一个振荡器周期，读取0号方格，读到了32，再读取32号方格，读到了2，发现是第二种指令，执行非运算和或运算后，最终8被写入了0号方格。至此0号方格又回到了最初的值，开始了新一轮的循环。

那么这个模块到底在干嘛？其实它就是一个16位2输入与门，根据德·摩根定律，A * B = ~ (~ A + ~ B)，假设每条指令的计算耗时均不超过1个时间单位，我们将2个输入分别放入5号和6号方格，等待4个时间单位后，7号方格就得到了结果。由于与门不在我们的操作列表里，所以这里我们用或门和非门实现了与门。我们把输入和输出方格标识出来，对这个模块进行重新描述如下：（注意表格中第一行的加粗字体并不表示什么含义，只是MarkDown的表格第一行会自动加粗）

#### A：16位2输入与门，振荡器周期1个时间单位，计算耗时4个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|2|3|7|1|31|0|32|
|2|7|7|1|38|0|8|0|

接下来基于2输入与门，我们就可以实现3输入与门：

#### B：16位3输入与门，振荡器周期4个时间单位，计算耗时20个时间单位

|8|0|0|0|in|in|in|out|
|-|-|-|-|-|-|-|-|
|1|1|4|Aa5|1|15|0|16|
|1|1|5|Aa6|1|23|0|24|
|1|1|Aa7|Ab5|1|31|0|32|
|1|1|6|Ab6|1|39|0|40|
|1|1|Ab7|7|1|47|0|8|

表格中大写字母开头的方格Aa5表示该方格硬连线到模块A的第5号方格，是编码为a的实例，就是说Aa和Ab都是2输入与门，但他们是两个不同的实例。另外由于该模块用到了A模块，所以它必须要等待A模块操作完，振荡器周期应设为4个时间单位。（这里B模块用到了A模块，假设我们称B为父模块，A为子模块，只要每个父模块的振荡器周期是所有它的子模块的计算耗时的倍数，即使子模块内部在中途修改了输出方格的值也没关系）

同样的，为了实现一点有趣的功能，我们还需要实现其他的基本模块：

#### X：16位2输入异或门，振荡器周期4个时间单位，计算耗时28个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|1|2|Aa5|1|31|0|32|
|1|1|6|Aa6|1|39|0|40|
|1|1|3|Ab5|1|47|0|48|
|1|1|5|Ab6|1|55|0|56|
|1|Aa7|Ab7|7|1|63|0|8|

这里要注意，X模块中的Aa和B模块中的Aa是不同的实例。

#### C：16位4输入或门，振荡器周期1个时间单位，计算耗时3个时间单位

|8|0|0|in|in|in|in|out|
|-|-|-|-|-|-|-|-|
|1|3|4|7|1|15|0|16|
|1|5|6|2|1|23|0|24|
|1|2|7|7|1|31|0|8|

#### P：1位全加器（依然使用16位运算），振荡器周期60个时间单位，计算耗时2040个时间单位

|16|0|0|in_carry|in|in|out|out_carry|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|2|3|11|1|22|0|24|0|
|2|4|12|1|30|0|32|0|
|2|5|13|1|38|0|40|0|
|1|1|11|Ba4|1|47|0|48|
|1|1|12|Ba5|1|55|0|56|
|1|1|5|Ba6|1|63|0|64|
|1|1|11|Bb4|1|71|0|72|
|1|1|4|Bb5|1|79|0|80|
|1|1|13|Bb6|1|87|0|88|
|1|1|3|Bc4|1|95|0|96|
|1|1|12|Bc5|1|103|0|104|
|1|1|13|Bc6|1|111|0|112|
|1|1|3|Bd4|1|119|0|120|
|1|1|4|Bd5|1|127|0|128|
|1|1|5|Bd6|1|135|0|136|
|1|1|11|Be4|1|143|0|144|
|1|1|4|Be5|1|151|0|152|
|1|1|5|Be6|1|159|0|160|
|1|1|3|Bf4|1|167|0|168|
|1|1|12|Bf5|1|175|0|176|
|1|1|5|Bf6|1|183|0|184|
|1|1|3|Bg4|1|191|0|192|
|1|1|4|Bg5|1|199|0|200|
|1|1|13|Bg6|1|207|0|208|
|1|1|Ba7|Ca3|1|215|0|216|
|1|1|Bb7|Ca4|1|223|0|224|
|1|1|Bc7|Ca5|1|231|0|232|
|1|1|Bd7|Ca6|1|239|0|240|
|1|1|Be7|Cb3|1|247|0|248|
|1|1|Bf7|Cb4|1|255|0|256|
|1|1|Bg7|Cb5|1|263|0|264|
|1|1|Bd7|Cb6|1|271|0|272|
|1|1|Ca7|6|1|279|0|280|
|1|1|Cb7|7|1|287|0|16|

#### Q：16位加法器，振荡器周期2040个时间单位，计算耗时99960个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|3|1*16|1*16|Pa3*16|1|15|0|16|
|3|1*16|5*16|Pa4*16|1|23|0|24|
|3|1*16|6*16|Pa5*16|1|31|0|32|
|3|1*16|Pa7*16|Pa3*16+1|1|39|0|40|
|3|1*16|5*16+1|Pa4*16+1|1|47|0|48|
|3|1*16|6*16+1|Pa5*16+1|1|55|0|56|
|3|1*16|Pa7*16+1|Pa3*16+2|1|63|0|64|
|3|1*16|5*16+2|Pa4*16+2|1|71|0|72|
|3|1*16|6*16+2|Pa5*16+2|1|79|0|80|
|3|1*16|Pa7*16+2|Pa3*16+3|1|87|0|88|
|3|1*16|5*16+3|Pa4*16+3|1|95|0|96|
|3|1*16|6*16+3|Pa5*16+3|1|103|0|104|
|3|1*16|Pa7*16+3|Pa3*16+4|1|111|0|112|
|3|1*16|5*16+4|Pa4*16+4|1|119|0|120|
|3|1*16|6*16+4|Pa5*16+4|1|127|0|128|
|3|1*16|Pa7*16+4|Pa3*16+5|1|135|0|136|
|3|1*16|5*16+5|Pa4*16+5|1|143|0|144|
|3|1*16|6*16+5|Pa5*16+5|1|151|0|152|
|3|1*16|Pa7*16+5|Pa3*16+6|1|159|0|160|
|3|1*16|5*16+6|Pa4*16+6|1|167|0|168|
|3|1*16|6*16+6|Pa5*16+6|1|175|0|176|
|3|1*16|Pa7*16+6|Pa3*16+7|1|183|0|184|
|3|1*16|5*16+7|Pa4*16+7|1|191|0|192|
|3|1*16|6*16+7|Pa5*16+7|1|199|0|200|
|3|1*16|Pa7*16+7|Pa3*16+8|1|207|0|208|
|3|1*16|5*16+8|Pa4*16+8|1|215|0|216|
|3|1*16|6*16+8|Pa5*16+8|1|223|0|224|
|3|1*16|Pa7*16+8|Pa3*16+9|1|231|0|232|
|3|1*16|5*16+9|Pa4*16+9|1|239|0|240|
|3|1*16|6*16+9|Pa5*16+9|1|247|0|248|
|3|1*16|Pa7*16+9|Pa3*16+10|1|255|0|256|
|3|1*16|5*16+10|Pa4*16+10|1|263|0|264|
|3|1*16|6*16+10|Pa5*16+10|1|271|0|272|
|3|1*16|Pa7*16+10|Pa3*16+11|1|279|0|280|
|3|1*16|5*16+11|Pa4*16+11|1|287|0|288|
|3|1*16|6*16+11|Pa5*16+11|1|295|0|296|
|3|1*16|Pa7*16+11|Pa3*16+12|1|303|0|304|
|3|1*16|5*16+12|Pa4*16+12|1|311|0|312|
|3|1*16|6*16+12|Pa5*16+12|1|319|0|320|
|3|1*16|Pa7*16+12|Pa3*16+13|1|327|0|328|
|3|1*16|5*16+13|Pa4*16+13|1|335|0|336|
|3|1*16|6*16+13|Pa5*16+13|1|343|0|344|
|3|1*16|Pa7*16+13|Pa3*16+14|1|351|0|352|
|3|1*16|5*16+14|Pa4*16+14|1|359|0|360|
|3|1*16|6*16+14|Pa5*16+14|1|367|0|368|
|3|1*16|Pa7*16+14|Pa3*16+15|1|375|0|376|
|3|1*16|5*16+15|Pa4*16+15|1|383|0|384|
|3|1*16|6*16+15|Pa5*16+15|1|391|0|392|
|1|1|Pa6|7|1|399|0|8|

这里用到了第三种指令按位或运算，所以表格中的1 * 16即16，Pa3 * 16即Pa48，按位寻址。另外进行位运算前无需清零，因为存储器在一开始已经全部清零。

#### M：5位比较器（存储单元依然为16位），相等输出0，不相等输出1，振荡器周期84个时间单位，计算耗时672个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|1|1|5|Xa5|1|15|0|16|
|1|1|6|Xa6|1|23|0|24|
|3|1*16|Xa7*16|Ca3*16|1|31|0|32|
|3|1*16|Xa7*16+1|Ca4*16|1|39|0|40|
|3|1*16|Xa7*16+2|Ca5*16|1|47|0|48|
|3|1*16|Xa7*16+3|Ca6*16|1|55|0|56|
|3|1*16|Ca7*16|7*16|1|63|0|64|
|3|Ca7*16|Xa7*16+4|Ca7*16|1|71|0|8|

#### S：16位比较选择器，比较前2个输入的数字（最大5位），相等则输出后2个输入的数字的前者，不相等则输出后2个输入的数字的后者，振荡器周期672个时间单位，计算耗时4704个时间单位

|16|0|8|in_num|in_num|in_addr|in_addr|out_addr|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|1|1|3|Ma5|1|23|0|24|
|1|1|4|Ma6|1|31|0|32|
|1|2|Ma7|Ma7|1|39|0|40|
|1|1|5|8|1|47|0|48|
|1|1|6|9|1|55|0|56|
|1|1|Ma7|66|1|63|0|64|
|1|1|0|7|1|71|0|16|

这里需要一点特殊的技巧，将5号方格的in_addr和6号方格的in_addr分别写入8号和9号方格，然后因此M模块的输出是0或者1，所以第五行将2号方格的8与Ma7进行或运算相当于对Ma7加8，即0+8=8或者1+8=9。另外66号方格最开始是0，但会被倒数第二行的指令修改，即自修改，只有这种自修改的方法才能实现条件选择。

#### Z：循环求和模块，计算1+2+3+4+5，振荡器周期399840个时间单位，计算耗时21991200个时间单位

|8|0|8|88|1|1|6|0|
|-|-|-|-|-|-|-|-|
|1|1|5|Qa5|1|15|0|16|
|1|1|7|Qa6|1|23|0|24|
|1|1|Qa7|7|1|31|0|32|
|1|1|4|Qa5|1|39|0|40|
|1|1|5|Qa6|1|47|0|48|
|1|1|Qa7|5|1|55|0|56|
|1|1|5|Sa3|1|63|0|64|
|1|1|6|Sa4|1|71|0|72|
|1|1|3|Sa5|1|79|0|80|
|1|1|2|Sa6|1|87|0|88|
|1|1|Sa7|95|1|95|0|0|

2号方格的8是第二行的起始编号，3号方格的88是最后一行的起始编号，4号方格用来每次加1，5号方格是循环变量，初始化为1，6号方格的6是循环变量的终止值。注意最后一个方格即95号方格，它的初始值是0，但它会被最后一行的指令根据S模块的输出值修改（又是自修改），也就是如果Sa3等于Sa4，则把Sa5（88）放入95号方格，如果Sa3不等于Sa4，则把Sa6（8）放入95号方格。所以最后一条指令相当于实现了条件跳转，根据情况选择跳转到8或者88。

经过21991200个时间单位后，我们在右上角（即7号方格）看到了1+2+3+4+5的计算结果15，最终该模块陷入了执行最后一行指令的无限循环。

但是无限循环的逼格始终不够高，相信看过《论可计算数及其在判定问题上的应用》和《计算机程序的构造和解释》的朋友应该对里面的元解释器印象深刻，下面我们也来实现一个元解释器：

#### I：元解释器，振荡器周期399840个时间单位，计算耗时取决于装入的程序

|16|0|88|280|440|56|0|0|
|-|-|-|-|-|-|-|-|
|1024|1|2|3|4|5|6|7|
|1|8|1024|Sa3|1|23|0|24|
|1|1|10|Sa4|1|31|0|32|
|1|1|3|Sa5|1|39|0|40|
|1|1|5|Sa6|1|47|0|48|
|1|1|Sa7|55|1|55|0|0|
|1|1|11|Sa4|1|63|0|64|
|1|1|4|Sa5|1|71|0|72|
|1|1|2|Sa6|1|79|0|80|
|1|1|Sa7|87|1|87|0|0|
|1|1|9|Qa5|1|95|0|96|
|1|8|1024|Qa6|1|103|0|104|
|1|1|Qa7|114|1|111|0|112|
|1|1|0|6|1|119|0|120|
|1|1|10|Qa5|1|127|0|128|
|1|8|1024|Qa6|1|135|0|136|
|1|1|Qa7|146|1|143|0|144|
|1|1|0|7|1|151|0|152|
|1|1|11|Qa5|1|159|0|160|
|1|8|1024|Qa6|1|167|0|168|
|1|1|Qa7|179|1|175|0|176|
|1|6|7|0|1|183|0|184|
|1|1|12|Qa5|1|191|0|192|
|1|8|1024|Qa6|1|199|0|200|
|1|1|Qa7|210|1|207|0|208|
|1|1|0|6|1|215|0|216|
|1|1|13|Qa5|1|223|0|224|
|1|8|1024|Qa6|1|231|0|232|
|1|1|Qa7|242|1|239|0|240|
|1|1|0|7|1|247|0|248|
|1|1|14|Qa5|1|255|0|256|
|1|8|1024|Qa6|1|263|0|264|
|1|1|Qa7|275|1|271|0|272|
|1|6|7|0|1|279|0|16|
|1|1|9|Qa5|1|287|0|288|
|1|8|1024|Qa6|1|295|0|296|
|1|1|Qa7|306|1|303|0|304|
|1|1|0|6|1|311|0|312|
|1|1|10|Qa5|1|319|0|320|
|1|8|1024|Qa6|1|327|0|328|
|1|1|Qa7|338|1|335|0|336|
|2|6|0|1|342|0|344|0|
|1|1|11|Qa5|1|351|0|352|
|1|8|1024|Qa6|1|359|0|360|
|1|1|Qa7|370|1|367|0|368|
|1|1|0|6|1|375|0|376|
|1|1|12|Qa5|1|383|0|384|
|1|8|1024|Qa6|1|391|0|392|
|1|1|Qa7|402|1|399|0|400|
|1|1|0|7|1|407|0|408|
|1|1|13|Qa5|1|415|0|416|
|1|2|1024|Qa6|1|423|0|424|
|1|1|Qa7|435|1|431|0|432|
|1|6|7|0|1|439|0|16|
|1|1|9|Qa5|1|447|0|448|
|1|8|1024|Qa6|1|455|0|456|
|1|1|Qa7|466|1|463|0|464|
|1|1|0|6|1|471|0|472|
|1|1|10|Qa5|1|479|0|480|
|1|8|1024|Qa6|1|487|0|488|
|1|1|Qa7|498|1|495|0|496|
|1|1|0|6|1|503|0|504|
|1|1|11|Qa5|1|511|0|512|
|1|8|1024|Qa6|1|519|0|520|
|1|1|Qa7|531|1|527|0|528|
|3|6|7|0|1|543|0|544|
|1|1|12|Qa5|1|551|0|552|
|1|8|1024|Qa6|1|559|0|560|
|1|1|Qa7|570|1|567|0|568|
|1|1|0|6|1|575|0|576|
|1|1|13|Qa5|1|583|0|584|
|1|8|1024|Qa6|1|591|0|592|
|1|1|Qa7|602|1|599|0|600|
|1|1|0|7|1|607|0|608|
|1|1|14|Qa5|1|615|0|616|
|1|8|1024|Qa6|1|623|0|624|
|1|1|Qa7|635|1|631|0|632|
|1|6|7|0|1|639|0|16|

只要把上面的循环求和模块Z装入1024开始的一堆方格中，等待一段时间即可看到1+2+3+4+5的计算结果15。注意只有最外层的模块是跑在解释器里的，其他子模块还是跑在真机里。

如果要模拟图灵机也可以用类似的方法，能模拟图灵机即可证明它是图灵完备的。
